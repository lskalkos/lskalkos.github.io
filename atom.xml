<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Lia.Skalkos]]></title>
  <link href="http://lskalkos.github.io/atom.xml" rel="self"/>
  <link href="http://lskalkos.github.io/"/>
  <updated>2015-07-07T21:31:49-04:00</updated>
  <id>http://lskalkos.github.io/</id>
  <author>
    <name><![CDATA[Lia Skalkos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Minority Report:<br />Ruby Exceptions & Errors]]></title>
    <link href="http://lskalkos.github.io/blog/2015/06/28/minority-report-exception-handling-in-ruby/"/>
    <updated>2015-06-28T16:25:01-04:00</updated>
    <id>http://lskalkos.github.io/blog/2015/06/28/minority-report-exception-handling-in-ruby</id>
    <content type="html"><![CDATA[<p>Not too long ago in one of our labs at Flatiron, we were asked to write some code that made this test pass:<br><br>
<code>
  it &ldquo;should raise an error for invalid types&rdquo; do
  expect { RPSGame.new(:dynamite) }.to raise_error(RPSGame::PlayTypeError)
  end<br/>
</code></p>

<p>After puzzling over this for a little, and reading some documentation, I got the test to pass by writing the following code:</p>

<p><code>
  class RPSGame
    attr_reader :type</p>

<pre><code>class PlayTypeError &lt; StandardError
end

def self.valid_types
  @@valid_types = [:rock, :paper, :scissors]
end

def initialize(type)
  @type = type
  raise(PlayTypeError.new) if !self.class.valid_types.include?(@type)
end
</code></pre>

<p>  end<br/>
</code></p>

<p>What was this neat little piece of code doing? Basically, raising an error if the user tried to enter an invalid action. I thought it was interesting, but soon moved on to other parts of the lab. However, I never forgot about the interesting little piece of code I had encountered. Ruby still feel inherently different to me than other parts of the language. They seem to be a little exotic, like rare birds in forest full of, I don&rsquo;t know, carrier pigeons. I guess this feeling makes sense, since exceptions tend to only come into play when things in our program go wrong. Also, there are a couple of special methods associated with them that not every class of object has. So, with that little intro here are a few things that are helpful in understanding exceptions:</p>

<ol>
  <li>
    <strong>First and foremost, exceptions are Ruby objects.</strong>
    <p>Like nearly everything in Ruby, exceptions are objects. This is great in that they can contain information about themselves, and can have a real presence within our programs. They can be passed around and instantiated whenever necessary.</p>
  </li>
  <li>
    <strong>Exceptions are for exceptional circumstances.</strong>
    <p>You probably don't want to use an exception in place of a well thought-out program and appropriate logic constraints. Say, in an application that already has built-in form/params logic, trying to guide the user towards a different input type. Instead, you probably want to make use of exceptions where it's reasonable that an unlikely but highly detrimental situation to your program could occur. It's nice here to spend some time thinking about what kind of tool exceptions are and where they would work best.</p>
    <p>Imagine we have an app that uses a 3rd party API. What happens if the connection times out, or the 3rd party's server is down, or for whatever other reason, their DNS isn't working? It's unlikely to happen, but because our application has this dependency, it's reasonable to have a contingency plan. This use case is a good example of where exceptions make a good fit. </p>
  </li>
  <li>
    <strong>Exceptions can be raised.</strong>
    <p>
      The raise method is from the Kernel module. By default, raise will create an exception of the RuntimeError class. To raise an exception of a specific class, you can pass in the class name as an argument.<br><br>
      <code>
        raise "Here is a regular RuntimeError"<br>
        raise StandardError.new("Here is a StandardError")
      </code>
    </p>
  </li>
  <li>
    <strong>When an exception is raised, it halts the program.</strong>
    <p>
      As a Ruby programmer, you encounter this on a day-to-day basis. Here's an example:<br>
      <code>
        "10" + 3<br>
        TypeError: no implicit conversion of Fixnum into String
      </code>
      There's no way to continue from here. Basically, this is where our program has ended up.
    </p>
  </li>
  <li>
    <strong>Exceptions are associated with begin/rescue blocks.</strong>
    <p>Begin/rescue blocks function a lot like if statements, in that if an exception is thrown in the "begin" part, you can rescue from it and essentially branch your program. Unlike an if statement, however, they can be a little more granular about what type of exception to rescue from.
      <div><script src='https://gist.github.com/28839b613ab07b5494db.js?file=gistfile1.rb'></script>
<noscript><pre><code>a = 7
b = &quot;10&quot;

begin
   a + b #executes the expression
rescue
   puts &quot;Could not add variables a (#{a.class}) and b (#{b.class})&quot; #if an an exception is raised, this part will fire
else
   puts &quot;a + b is #{a + b}&quot; #otherwise, this part will fire 
end</code></pre></noscript></div>
</p>
  </li>
  <li>
    <strong>Exceptions have methods.</strong>
    <p>This ties into #1. They basically are backtrace, message, and inspect.</p>
  </li>
  <li>
    <strong>Make sure you specify the Exception type you are rescuing from.</strong>
    <p>Probably the most important point for last. Errors inherit from the class Exception. Exception has a big family tree. When you rescue from an Exception, be sure to be as specific as possible about the type, so that you don't accidentally rescue from an exception you weren't anticipating.</p>
  </li>
</ol>


<p>Sources:<br>
<a href="http://daniel.fone.net.nz/blog/2013/05/28/why-you-should-never-rescue-exception-in-ruby/"><a href="http://daniel.fone.net.nz/blog/2013/05/28/why-you-should-never-rescue-exception-in-ruby/">http://daniel.fone.net.nz/blog/2013/05/28/why-you-should-never-rescue-exception-in-ruby/</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Efficient Coding With Rubymine:<br />a Quick Guide]]></title>
    <link href="http://lskalkos.github.io/blog/2015/06/20/efficient-coding-with-rubymine/"/>
    <updated>2015-06-20T11:04:32-04:00</updated>
    <id>http://lskalkos.github.io/blog/2015/06/20/efficient-coding-with-rubymine</id>
    <content type="html"><![CDATA[<p>Programmers tend to be a crew that likes their tools. From the OS, to version control, to bash and Ruby itself, one could argue that pretty much every aspect of programming involves a tool. Usually, the linchpin of all these tools is the text editor, the place where the code actually gets written. Recently, instead of using Sublime Text, I&rsquo;ve been using an <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> called Rubymine. While I&rsquo;m a fan of Sublime Text, I&rsquo;ve been finding that Rubymine provides some advantages that give me a boost in efficiency. In this post I give a quick review of some of Rubymine&rsquo;s features.</p>

<h3>Debugging</h3>


<p>Rubymine comes with a built in visual debugger that can function as an alternative to debugging with pry. Let&rsquo;s take a look at how this works.</p>

<p>Navigate over to the rspec test you want to run (or the file that serves as your program&rsquo;s entry point), right click, and select debug (or Option + Shift + D). You can also select a specific test to run within a spec. If there are no bugs, your test will pass and your program will run. When you debug, three tabs will open up at the bottom: the Debugger, Console, and Interactive Console. The Console reports the output of your test, and will alert you if there are any errors. Let&rsquo;s say you run a test and you hit an error. Here are the steps you can take to take advantage of Rubymine&rsquo;s debugging capabilities:</p>

<ol>
<li><p>Head over to the line in your program where Ruby ran into a problem.</p></li>
<li><p>Set a &ldquo;breakpoint&rdquo; &ndash; this is very similar to setting a binding.pry. The next time your program runs Rubymine will stop it at this point. Use Command + fn + F8 to set a breakpoint. You can set several of these at a time. <img src="images/rubymine_breakpoint.png" style="display: block; margin: 20px auto 20px;"/></p></li>
<li><p>Rerun your debugger (Option + Shift + D).</p></li>
<li><p>Now, when you check the debugger tab you&rsquo;ll be shown the current values of the local variables within the scope of your breakpoint <em>and</em> Rubymine will write out these values in your actual code. You can also get access to an Expression Evaluator and can set a watch or a condition on variables or expresssions to see how they change as you move through your code. <img src="images/rubymine_local_variables.png" style="displauy: block; margin: 20px auto 20px;"/></p></li>
<li><p>Head over to the Interactive Console for an IRB that gives you access to these variables.</p></li>
<li><p>Once you&rsquo;ve corrected your code, hit &lsquo;Rerun&rsquo; to rerun your test.</p></li>
</ol>


<p>This might not sound like it&rsquo;s that different from using pry, but when you&rsquo;re debugging, getting visual cues and having all of the information in one place without having to run multiple commands and switch between panels seems invaluable.</p>

<h3>Syntax Highlighting & Auto Suggestion</h3>


<p>Rubymine remembers your classes and their methods no matter where you are in your program, so when you reference a class or create a new instance it provides a list of method suggestions. Pretty helpful when you&rsquo;re trying to remember a method. Also, unlike Sublime Text, it provides code completion and signals you when you have a syntax error or have misused a local variable. No more having to type &ldquo;end&rdquo; to a if block.</p>

<p><img src="images/rubymine_autosuggest.png" style="display: block; margin: 20px auto 20px;"/></p>

<h3>Terminal</h3>


<p></p>

<p>You can run bash directly from Rubymine. Need I say more? No more need to shift + tab back and forth from terminal.</p>

<p>The Verdict?</p>

<p>Rubymine seems to be super powerful. It has other features which I haven&rsquo;t begun to explore, like other language and refactoring support. It&rsquo;s keyboard-centric, which means it&rsquo;s meant to be handled through keyboard commands as much as possible. Of course, having to learn a bunch of keyboard commands can be time-consuming and an extra stress when you&rsquo;re already trying to learn something new. But, once you have a good number down, they save you a lot of time. Rubymine definitely takes more time to learn than Sublime Text, and can be a learning project all on its own. There are a ton of features, which can seem overwhelming and like a distraction from the actual task: coding. Also, at $99 for an individual license, it&rsquo;s not cheap. But an upfront investment of time and money seems very likely to payoff in terms of efficiency and support.</p>

<p>Some purists might argue that they like sparse tools like Vim better because they can code right from the command line. In my view, why not use a tool that can provide you more context immediately? When you&rsquo;re doing something as cognitively involved as coding, it helps to have all the signaling you can get.</p>

<p>In the end, there is no &ldquo;best&rdquo; text editor or environment set up &ndash; it&rsquo;s a matter of individual taste and circumstance and what you feel supports you best in your workflow. As long as a tool is empowering you, it&rsquo;s worthwhile. I&rsquo;m still getting to know Rubymine, but for now, I&rsquo;m enjoying it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zen and the Art of Programming]]></title>
    <link href="http://lskalkos.github.io/blog/2015/06/09/zen-and-the-art-of-programming/"/>
    <updated>2015-06-09T17:21:57-04:00</updated>
    <id>http://lskalkos.github.io/blog/2015/06/09/zen-and-the-art-of-programming</id>
    <content type="html"><![CDATA[<p><em>Practice makes the master.</em> -Spanish saying</p>

<p>Some time ago, I was applying for a developer job at a startup. Part of the application process involved solving a code challenge that required you to programmatically retrieve and manipulate a set of data through an API. I chose to do the challenge in Node.js, because I like Node (and Javascript-y things in general) and because Node was a key part of the company&rsquo;s product and of the job I was applying for.</p>

<p>I remember firing up Sublime, writing some preliminary code, and retrieving the first set of data. I felt great. I felt like, &ldquo;I got this&rdquo;. In fact, I had a lot of big feelings about this one code challenge. Up until that point, I was largely a self-taught developer. I thought, how amazing would it be if I got this job, having learned to code mostly on my own. Like, it would be mean I Am Really Smart after all and Totally A Real Developer and all these other big things that would validate me and free me from my insecurities. Then I got deeper into the problem.</p>

<p>Long story short, I hit a <a href="http://en.wikipedia.org/wiki/Tree_(data_structure)">nested tree-like structure</a> part of the problem. I tried recursion, but that seemed to be a friggin nightmare. Then a colleague suggested I try a queue instead of recursion. That seemed to be better, but I was still in <a href="http://callbackhell.com">callback hell</a> thanks to Javascript&rsquo;s lovely <a href="https://msdn.microsoft.com/en-us/library/windows/apps/hh700330.aspx">asynchronous nature</a>.</p>

<p>The details of the problem are largely unimportant. What <em>is</em> important is that I spent a weekend on the problem. Actually, more than a weekend on it. From the time I received the challenge, I spent literally every waking second on it, well into the week, well into when I should not have been thinking about it anymore, like when I should have been eating or taking bathroom breaks or sleeping. I was totally out of my element, and that was incredibly hard to accept. For most of that week, I couldn&rsquo;t even understand what my problem was, let alone how to fix it. It took me half the week alone to learn about tree structures &ndash; a way for me to conceptualize the problem &ndash; and even more days for me to learn about callback hell, and about Javascript&rsquo;s asynchronous nature.</p>

<p>The important thing about the problem was not that I solved it, but that I couldn&rsquo;t solve it, no matter how hard I tried, no matter how much I wanted it. It was torture. Just like I had felt solving the problem would say something great about me, not solving the problem seemed to say something awful about me.</p>

<p>So much in life is actually pretty easy. You show up, you do the work, you get the credit. Actually, most things in life are pretty effortless. And so even when we know we have to put in the time to learn something, or to solve something, we still expect that process to be effortless. Like a savings account, we expect to put some time in and get a reliable return.</p>

<p>But sometimes things are beyond our control. Sometimes you can&rsquo;t solve that problem, at least, not right now, perhaps in this place, not in this way, or with this tool. I couldn&rsquo;t solve the problem on my own through the sheer force of my intellect. I researched it, wrestled with it, and yet I still didn&rsquo;t &ldquo;win&rdquo; &ndash; though what exactly I was trying to win remains a mystery.</p>

<p>Here is the paradox: we can&rsquo;t fully believe in our own mastery if it has been effortless. Problems in programming, as in life, require patience and faith &ndash; the faith that they will be resolved in time, though perhaps not in the way you would like, and the patience to struggle for awhile, though it may be uncomfortable for much longer than you anticipate. It is here where I like the Zen concept of beginner mind. No matter how experienced we are, if we always think of ourselves as a beginner, we can approach a problem with humility, openness, and a certain amount of self-gentleness. We can accept our frustration simply as evidence that we care deeply about our craft, and that we want it to be worth the struggle. In the words of one of my former coworkers, &ldquo;All is practice.&rdquo; If we are always practicing, then we are always learning. If we are always learning, then we have never fully arrived, and that&rsquo;s okay, because that was never really the point anyway. Mastery is not a binary state but a gradual unfolding, revealing itself to you when you least expect it.</p>

<p>The truth was this: my experience on this particular problem didn&rsquo;t say anything about me beyond the fact that I struggled with it for a while. It was just a moment in time.</p>

<p>In the end, I did end up submitting a beautiful little program with the help of my colleague and <a href="https://www.promisejs.org">Promises.js</a>. It worked, and while I didn&rsquo;t end up working for the company, I gained so much more by pushing myself farther beyond where I possibly thought I could go.</p>
]]></content>
  </entry>
  
</feed>
